name: 'Windows Signing'
description: 'Sign files on Windows'
inputs:
  base-dir:
    description: 'The base directory to search for files'
    required: true
  file-glob:
    description: 'List of file glob patterns to sign, separated by commas'
    required: true
  recursive:
    description: 'Whether to search recursively in subdirectories'
    required: false
    default: false
  sign-description:
    description: 'Signature description'
    required: false
    default: 'Cryptomator'
  sign-url:
    description: 'Signature URL'
    required: false
    default: 'https://cryptomator.org'

env:
  SIGNER_PATH: ${{ github.workspace }}/actalis-signer/ActalisCodeSigner.exe
  SIGNER_NAME: actalis-signer
  SIGNER_URL: 'https://static.cryptomator.org/other/CodeSigner-win-x64-latest.zip'
  SIGNER_HASH: '44a1e09ab72707d049d3e59656e3e35de92e8cda357eec1cfc367016e45835ab'
runs:
  using: "composite"
  steps:
    - name: Check if signer is available
      run: |
        if (Test-Path ${{ env.SIGNER_PATH }}) {
          echo "signer-available=true" >> $GITHUB_OUTPUT
        } else {
          echo "signer-available=false" >> $GITHUB_OUTPUT
        }
      shell: pwsh
    - name: Download signer if not present
      if: steps.check.outputs.signer-available == 'false'
      run: |
        curl --output "${{ env.SIGNER_NAME }}.zip" -L "${{ env.SIGNER_URL }}"
        if (!(Get-FileHash -Path "${{ env.SIGNER_NAME }}.zip" -Algorithm SHA256).Hash.ToLower().equals("${{ env.SIGNER_HASH }}")) {
          echo "Signer hash mismatch, exiting."
          exit 1
        }
        Expand-Archive -Path "${{ env.SIGNER_NAME }}.zip" -DestinationPath "${{ env.SIGNER_NAME }}" -Force
      shell: pwsh
    - name: Sign DLLs with Actalis CodeSigner
      if: inputs.sign || github.event_name == 'release'
      shell: pwsh
      run: |
        $ThrottleLimit = 5
        $recursive = ${{ inputs.recursive }} -eq 'true'
        $files = Get-ChildItem -Path "${{ inputs.base-dir }}" -Include "${{ inputs.file-glob }}" -Recurse:$recursive
        $cancellationSource = [System.Threading.CancellationTokenSource]::new()
        $token = $cancellationSource.Token
        $errors = [System.Collections.Concurrent.ConcurrentBag[string]]::new()
        $jobs = [System.Collections.Generic.List[object]]::new()

        # PROCESSING LOOP WITH THROTTLING
        foreach ($file in $files) {
            # Throttle: wait for a slot
            while (($jobs | Where-Object { $_.State -eq 'Running' }).Count -ge $ThrottleLimit) {
                Start-Sleep -Milliseconds 1000
            }

            # Start the signing job
            $job = Start-ThreadJob -ScriptBlock {
                param($filePath, $token, $errors, $cancellationSource)

                if ($token.IsCancellationRequested) { return }

                & ${{ env.SIGNER_PATH }} -ts -fu ${{ secrets.WIN_CODESIGN_USERNAME }} -fp ${{ secrets.WIN_CODESIGN_PASSWORD }} -pm "${{ inputs.sign-description }}" --program-url "${{ inputs.sign-url }}" -in $filePath *> $null

                if ($LASTEXITCODE -ne 0) {
                    $errors.Add("Signing failed for $filePath")
                    $cancellationSource.Cancel()  # Trigger cancellation for other jobs
                }
            } -ArgumentList $file.FullName, $token, $errors, $cancellationSource

            $jobs.Add($job)
        }

        # Wait for remaining jobs
        $jobs | Wait-Job

        # Final result
        if ($errors.Count -gt 0) {
            Write-Host "`n❌ Error occurred:"
            $errors | Select-Object -First 1 | Write-Host
            exit 1
        }
        else {
            Write-Host "`n✅ All files signed successfully."
        }
